# Декоратор - это функция, которая в качестве аргумента принимает другую функцию и возвращает функцию-замыкание.
# Декораторы нужны для расширения функционала переданной функции за счет обертки в замыкании
def decorator(func):  # это функция, которая в качестве аргумента принимает другую функцию (со строки 11)
    def inner(*args, **kwargs):  # поскольку мы не знаем сколько мы будем вызывать (из say или bye),то лучше *args
        print('<h1>')  # открытие тега
        func(*args, **kwargs)  # или func(input('Введите ваше имя: '))
        print('</h1>')  # закрытие тега

    return inner  # возвращает функцию-замыкание.


def say(surname, name):
    print('Hello', surname, name)


say = decorator(say)  # присвоили в функцию say действие функции decorator в которую передали значение от старой функции
# say в 12-й строке действие которой выполнится в 6-й строке при её вызове
say('Асмоловский', 'Андрей')  # <h1>  Hello Асмоловский Андрей  </h1>


def bye(surname, name):
    print('Bye', surname, name)


bye = decorator(bye)  # сделали тоже самое что в 16-й строке, но значение передали с 21-й строки
bye('Асмоловская', 'Кристина')  # <h1>  Bye Асмоловская Кристина  </h1>


def table(func):
    def inner(*args, **kwargs):
        print('<table>')  # открытие тега
        func(*args, **kwargs)
        print('</table>')  # закрытие тега

    return inner


# можно на 1-у функцию "повесить" несколько декораторов
povesa = decorator(table(say))  # сделает сначала table а потом его результат выведет в 6-й строке в decorator
povesa('Asmolovkii', 'Andrey')  # <h1> <table> Hello Asmolovkii Andrey </table> </h1>
# если перед функцией поставить например say сделать это, то она атоматом обвернёт эту функцию :
# @decorator
# @table если написать несколько то будет их обворачивать по очереди до написанной функции
# say = decorator(table(say))
# say('Асмоловский', 'Андрей')
